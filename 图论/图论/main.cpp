/*基于位运算求图论，感觉很nice的一个方法，所以在这里总结吸收一下*/
/*原题链接：https://www.acwing.com/problem/content/93/ */
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 20, m = 1 << 20;
//通过位运算来储存状态是一个比较高明的压缩手法，这里由于最大使20个地区，所以用了20个2进制位。
int n = 20;
//weight定义每条边的权重
int weight[N][N];
//目测使用动规思路来记录，m使状态值，N是当前的点
int f[m][N];

int main() {
	//输入
	cin >> n;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			cin >> weight[i][j];

	//将f中的所有值全部调到无穷大，因为我们求的最短路径，所以刚开始将权值设置最大方便后面数据更新
	memset(f, 0x3f, sizeof f);
	//我们从第一个点开始，所以在二进制码中，第一个为值状态为1，表示已经过，此时还在起点，路径为大小为0
	f[1][0] = 0;

	//开始算法正文，从0开始遍历每一个状态值
	for (int i = 0; i < 1 << n; i++)
		//j表示当前点目前所储存的到这里最短路径的大小
		for (int j = 0; j < n; j++)
			/*判断j这个位置我们是否开始考虑了，没有的话暂时跳过
			举个简单的例子，当我们在i = 5的时候，转化成二进制码为
			101，表示我们经过第一个点和第三个点，所以我们后面算法
			只考虑已经经过的点*/
			if (i >> j & 1)
				//定义k主要是为了计算之前点的大小
				for (int k = 0; k < n; k++)
					//去除当前点，找到遍历中的k点，进行大小比较更新
					if (i - (1 << j) >> k & 1)
						/*动态规划，更新当前状态的最短路径，比较为当前点的大小，
						和我们之前遍历到的点k位置的路径，加上两点之间的路径*/
						f[i][j] = min(f[i][j], f[i - (1 << j)][k] + weight[k][j]);

	cout << f[(1 << n) - 1][n - 1] << endl;
	return 0;
}